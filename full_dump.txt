
==== ./storage-backend/.env ====

DATABASE_URL=mysql://root:root@localhost:3306/storage_file_library
PORT=3002
==== ./storage-backend/package.json ====

{
  "name": "storage-backend",
  "version": "1.0.0",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "nodemon dist/index.js",
    "migrate": "npx prisma migrate dev --name init",
    "generate": "npx prisma generate"
  },
  "dependencies": {
    "@prisma/client": "^6.13.0",
    "axios": "^1.7.7",
    "class-validator": "^0.14.1",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.21.0",
    "mysql2": "^3.11.3",
    "reflect-metadata": "^0.2.2",
    "routing-controllers": "^0.10.4"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/node": "^22.7.4",
    "nodemon": "^3.1.7",
    "prisma": "^6.13.0",
    "typescript": "^5.6.2"
  }
}

==== ./storage-backend/prisma/migrations/migration_lock.toml ====

# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "mysql"

==== ./storage-backend/prisma/migrations/20250730055032_init/migration.sql ====

-- CreateTable
CREATE TABLE `File` (
    `id` VARCHAR(191) NOT NULL,
    `name` VARCHAR(191) NOT NULL,
    `type` VARCHAR(191) NOT NULL,
    `size` INTEGER NOT NULL,
    `path` VARCHAR(191) NOT NULL,
    `createdAt` DATETIME(3) NOT NULL,
    `updatedAt` DATETIME(3) NOT NULL,
    `isFolder` BOOLEAN NOT NULL,
    `folderId` VARCHAR(191) NULL,
    `thumbnail` VARCHAR(191) NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- AddForeignKey
ALTER TABLE `File` ADD CONSTRAINT `File_folderId_fkey` FOREIGN KEY (`folderId`) REFERENCES `File`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

==== ./storage-backend/prisma/schema.prisma ====

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model File {
  id        String    @id
  name      String
  type      String
  size      Int
  path      String
  createdAt DateTime
  updatedAt DateTime
  isFolder  Boolean
  folderId  String?
  thumbnail String?
  parent    File?     @relation("FolderStructure", fields: [folderId], references: [id])
  children  File[]    @relation("FolderStructure")
}
==== ./storage-backend/tsconfig.json ====

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "sourceMap": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}

==== ./storage-backend/src/services/StorageService.ts ====

import { PrismaClient } from "@prisma/client";
import { StorageFileDTO } from "../dtos/StorageFileDTO";
import { StorageResponseDTO } from "../dtos/StorageResponseDTO";

export class StorageService {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  async uploadFile(fileData: StorageFileDTO): Promise<StorageResponseDTO> {
    const fileId = Math.random().toString(36).substr(2, 9);
    const size = fileData.isFolder ? 0 : Math.floor(Math.random() * 10000000);

    const file = await this.prisma.file.create({
      data: {
        id: fileId,
        name: fileData.name,
        type: fileData.type,
        size,
        path: fileData.path,
        createdAt: fileData.createdAt,
        updatedAt: fileData.updatedAt,
        isFolder: fileData.isFolder,
        folderId: fileData.folderId,
        thumbnail: fileData.type.startsWith("image/")
          ? `/thumbnails/${fileId}`
          : undefined,
      },
    });

    return {
      id: file.id,
      name: file.name,
      type: file.type,
      size: file.size,
      path: file.path,
      createdAt: file.createdAt,
      updatedAt: file.updatedAt,
      isFolder: file.isFolder,
      folderId: file.folderId,
      thumbnail: file.thumbnail,
    };
  }

  async deleteFile(fileId: string): Promise<void> {
    await this.prisma.file.delete({
      where: { id: fileId },
    });
  }

  async moveFile(
    fileId: string,
    folderId?: string
  ): Promise<StorageResponseDTO> {
    const file = await this.prisma.file.update({
      where: { id: fileId },
      data: { folderId: folderId || null },
    });

    return {
      id: file.id,
      name: file.name,
      type: file.type,
      size: file.size,
      path: file.path,
      createdAt: file.createdAt,
      updatedAt: file.updatedAt,
      isFolder: file.isFolder,
      folderId: file.folderId,
      thumbnail: file.thumbnail,
    };
  }
}

==== ./storage-backend/src/types/index.ts ====

export interface File {
  id: string;
  name: string;
  type: string;
  size: number;
  path: string;
  createdAt: Date;
  updatedAt: Date;
  isFolder: boolean;
  folderId?: string;
  thumbnail?: string;
}

==== ./storage-backend/src/config/database.ts ====

import mysql from "mysql2/promise";
import dotenv from "dotenv";

dotenv.config();

export async function initializeDatabase() {
  const databaseUrl = process.env.DATABASE_URL;
  if (!databaseUrl) {
    throw new Error("DATABASE_URL environment variable is not defined");
  }

  const [userInfo, hostInfo] = databaseUrl.split("@");
  const [user, password] = userInfo.split("://")[1].split(":");
  const [host, portAndDb] = hostInfo.split(":");
  const [port, dbName] = portAndDb.split("/");

  const connection = await mysql.createConnection({
    host: host || "localhost",
    port: parseInt(port) || 3306,
    user: user || "root",
    password: password || "password",
  });

  const finalDbName = dbName.split("?")[0] || "storage_file_library";
  await connection.query(`CREATE DATABASE IF NOT EXISTS ${finalDbName}`);
  await connection.end();
}

==== ./storage-backend/src/controllers/StorageController.ts ====

import {
  JsonController,
  Post,
  Delete,
  Put,
  Body,
  Param,
  HttpError,
} from "routing-controllers";
import { validate } from "class-validator";
import { StorageService } from "../services/StorageService";
import { StorageFileDTO } from "../dtos/StorageFileDTO";
import { StorageResponseDTO } from "../dtos/StorageResponseDTO";

@JsonController("/api/storage")
export class StorageController {
  private storageService: StorageService;

  constructor() {
    this.storageService = new StorageService();
  }

  @Post("/upload")
  async uploadFile(
    @Body() fileData: StorageFileDTO
  ): Promise<StorageResponseDTO> {
    try {
      console.log("Received payload in StorageController:", fileData);
      const errors = await validate(fileData);
      if (errors.length > 0) {
        console.error("Validation errors:", errors);
        throw new HttpError(
          400,
          `Validation failed: ${JSON.stringify(errors)}`
        );
      }
      const result = await this.storageService.uploadFile(fileData);
      console.log("StorageService response:", result);
      return result;
    } catch (error: any) {
      console.error("StorageController uploadFile error:", error);
      throw new HttpError(500, `Failed to store file: ${error.message}`);
    }
  }

  @Delete("/:id")
  async deleteFile(@Param("id") fileId: string): Promise<{ message: string }> {
    try {
      await this.storageService.deleteFile(fileId);
      return { message: "File deleted from storage" };
    } catch (error: any) {
      console.error("StorageController deleteFile error:", error);
      throw new HttpError(
        500,
        `Failed to delete file from storage: ${error.message}`
      );
    }
  }

  @Put("/:id/move")
  async moveFile(
    @Param("id") fileId: string,
    @Body() body: { folderId?: string }
  ): Promise<StorageResponseDTO> {
    try {
      return await this.storageService.moveFile(fileId, body.folderId);
    } catch (error: any) {
      console.error("StorageController moveFile error:", error);
      throw new HttpError(
        500,
        `Failed to move file in storage: ${error.message}`
      );
    }
  }
}

==== ./storage-backend/src/dtos/StorageFileDTO.ts ====

import {
  IsString,
  IsNotEmpty,
  IsOptional,
  IsUUID,
  IsBoolean,
  IsDate,
} from "class-validator";

export class StorageFileDTO {
  @IsString()
  @IsNotEmpty()
  name!: string;

  @IsString()
  @IsNotEmpty()
  type!: string;

  @IsString()
  @IsNotEmpty()
  path!: string;

  @IsOptional()
  @IsUUID()
  folderId?: string;

  @IsDate()
  createdAt!: Date;

  @IsDate()
  updatedAt!: Date;

  @IsBoolean()
  isFolder!: boolean;
}

==== ./storage-backend/src/dtos/StorageResponseDTO.ts ====

export class StorageResponseDTO {
  id!: string;
  name!: string;
  type!: string;
  size!: number;
  path!: string;
  createdAt!: Date;
  updatedAt!: Date;
  isFolder!: boolean;
  folderId!: string | null;
  thumbnail!: string | null;
}

==== ./storage-backend/src/index.ts ====

import "reflect-metadata"; // Must be imported first
import express from "express";
import { useExpressServer } from "routing-controllers";
import cors from "cors";
import { createServer } from "http";
import dotenv from "dotenv";
import { initializeDatabase } from "./config/database";
import { StorageController } from "./controllers/StorageController";
import { PrismaClient } from "@prisma/client";

dotenv.config();

async function main() {
  await initializeDatabase();
  console.log("Successfully connected to MySQL database: storage_file_library");

  const prisma = new PrismaClient({
    log: ["query", "info", "warn", "error"],
    errorFormat: "pretty",
  });
  try {
    await prisma.$connect();
    console.log("Prisma successfully connected to the database");
    await prisma.file.findMany({ take: 1 });
    console.log("Prisma schema validated successfully");
  } catch (error) {
    console.error("Prisma failed to connect to the database:", error);
    process.exit(1);
  }

  const app = express();
  const port = process.env.PORT || 3002;

  // Explicitly use express.json() first to handle JSON parsing
  app.use(express.json({ limit: "10mb" }));
  app.use(cors());

  const server = createServer(app);

  useExpressServer(app, {
    controllers: [StorageController],
    defaultErrorHandler: false,
    defaults: {
      paramOptions: {
        required: true,
      },
    },
  });

  server.listen(port, () => {
    console.log(`Storage backend running on port ${port}`);
  });
}

main().catch((error) => {
  console.error("Failed to start Storage Backend:", error);
  process.exit(1);
});

==== ./storage-backend/nodemon.json ====

{
  "watch": ["dist"],
  "ext": "js",
  "exec": "node dist/index.js"
}

==== ./structure.txt ====

.
├── frontend-backend
│   ├── .env
│   ├── nodemon.json
│   ├── package.json
│   ├── package-lock.json
│   ├── prisma
│   │   ├── migrations
│   │   │   ├── 20250730041844_init
│   │   │   │   └── migration.sql
│   │   │   └── migration_lock.toml
│   │   └── schema.prisma
│   ├── src
│   │   ├── config
│   │   │   └── database.ts
│   │   ├── controllers
│   │   │   └── FileController.ts
│   │   ├── dtos
│   │   │   ├── FileResponseDTO.ts
│   │   │   └── FileUploadDTO.ts
│   │   ├── index.ts
│   │   ├── services
│   │   │   └── FileService.ts
│   │   └── types
│   │       └── index.ts
│   ├── tsconfig.json
│   └── yarn.lock
├── storage-backend
│   ├── .env
│   ├── nodemon.json
│   ├── package.json
│   ├── package-lock.json
│   ├── prisma
│   │   ├── migrations
│   │   │   ├── 20250730055032_init
│   │   │   │   └── migration.sql
│   │   │   └── migration_lock.toml
│   │   └── schema.prisma
│   ├── src
│   │   ├── config
│   │   │   └── database.ts
│   │   ├── controllers
│   │   │   └── StorageController.ts
│   │   ├── dtos
│   │   │   ├── StorageFileDTO.ts
│   │   │   └── StorageResponseDTO.ts
│   │   ├── index.ts
│   │   ├── services
│   │   │   └── StorageService.ts
│   │   └── types
│   │       └── index.ts
│   └── tsconfig.json
└── structure.txt

20 directories, 32 files

==== ./full_dump.txt ====


==== ./frontend-backend/.env ====

PORT=3001
DATABASE_URL=mysql://root:root@localhost:3306/frontend_file_library 
STORAGE_BACKEND_URL=http://localhost:3002 
==== ./frontend-backend/package.json ====

{
  "name": "frontend-backend",
  "version": "1.0.0",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "nodemon dist/index.js",
    "migrate": "npx prisma migrate dev --name init",
    "generate": "npx prisma generate"
  },
  "dependencies": {
    "@prisma/client": "^6.13.0",
    "axios": "^1.7.7",
    "class-validator": "^0.14.1",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.21.0",
    "mysql2": "^3.11.3",
    "reflect-metadata": "^0.2.2",
    "routing-controllers": "^0.10.4"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/node": "^22.7.4",
    "nodemon": "^3.1.7",
    "prisma": "^6.13.0",
    "typescript": "^5.6.2"
  }
}

==== ./frontend-backend/prisma/migrations/20250730041844_init/migration.sql ====

-- CreateTable
CREATE TABLE `File` (
    `id` VARCHAR(191) NOT NULL,
    `name` VARCHAR(191) NOT NULL,
    `type` VARCHAR(191) NOT NULL,
    `size` INTEGER NOT NULL,
    `path` VARCHAR(191) NOT NULL,
    `createdAt` DATETIME(3) NOT NULL,
    `updatedAt` DATETIME(3) NOT NULL,
    `isFolder` BOOLEAN NOT NULL,
    `folderId` VARCHAR(191) NULL,
    `thumbnail` VARCHAR(191) NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- AddForeignKey
ALTER TABLE `File` ADD CONSTRAINT `File_folderId_fkey` FOREIGN KEY (`folderId`) REFERENCES `File`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

==== ./frontend-backend/prisma/migrations/migration_lock.toml ====

# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "mysql"

==== ./frontend-backend/prisma/schema.prisma ====

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model File {
  id        String    @id
  name      String
  type      String
  size      Int
  path      String
  createdAt DateTime
  updatedAt DateTime
  isFolder  Boolean
  folderId  String?
  thumbnail String?
  parent    File?     @relation("FolderStructure", fields: [folderId], references: [id])
  children  File[]    @relation("FolderStructure")
}
==== ./frontend-backend/tsconfig.json ====

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "sourceMap": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}

==== ./frontend-backend/src/services/FileService.ts ====

import { PrismaClient } from "@prisma/client";
import axios, { AxiosError } from "axios";
import { FileUploadDTO } from "../dtos/FileUploadDTO";
import { FileResponseDTO } from "../dtos/FileResponseDTO";
import { File } from "../types";

export class FileService {
  private prisma: PrismaClient;
  private storageBackendUrl: string;

  constructor() {
    this.prisma = new PrismaClient();
    this.storageBackendUrl =
      process.env.STORAGE_BACKEND_URL || "http://localhost:3002";
  }

  async getFiles(folderId?: string): Promise<FileResponseDTO[]> {
    const files = await this.prisma.file.findMany({
      where: { folderId: folderId || null },
    });

    return files.map((file) => ({
      id: file.id,
      name: file.name,
      type: file.type,
      size: file.size,
      path: file.path,
      createdAt: file.createdAt,
      updatedAt: file.updatedAt,
      isFolder: file.isFolder,
      folderId: file.folderId,
      thumbnail: file.thumbnail,
    }));
  }

  async uploadFile(uploadData: FileUploadDTO): Promise<FileResponseDTO> {
    try {
      const now = new Date().toISOString();
      const storagePayload = {
        name: uploadData.name,
        type: uploadData.type,
        path: uploadData.path,
        folderId: uploadData.folderId,
        createdAt: now,
        updatedAt: now,
        isFolder: false,
      };

      console.log("Sending to Storage Backend:", storagePayload);

      const storageResponse = await axios.post(
        `${this.storageBackendUrl}/api/storage/upload`,
        storagePayload,
        {
          headers: { "Content-Type": "application/json" },
        }
      );

      console.log("Storage Backend Response:", storageResponse.data);

      const file = await this.prisma.file.create({
        data: {
          ...uploadData,
          id: storageResponse.data.id,
          size: storageResponse.data.size,
          createdAt: new Date(),
          updatedAt: new Date(),
          isFolder: false,
          thumbnail: storageResponse.data.thumbnail,
        },
      });

      return {
        id: file.id,
        name: file.name,
        type: file.type,
        size: file.size,
        path: file.path,
        createdAt: file.createdAt,
        updatedAt: file.updatedAt,
        isFolder: file.isFolder,
        folderId: file.folderId,
        thumbnail: file.thumbnail,
      };
    } catch (error: any) {
      if (error instanceof AxiosError) {
        console.error("Axios error details:", {
          status: error.response?.status,
          data: error.response?.data,
          message: error.message,
          config: error.config,
        });
        throw new Error(
          `Storage backend error: ${
            error.response?.status || "unknown"
          } - ${JSON.stringify(error.response?.data || error.message)}`
        );
      }
      console.error("Upload error:", error);
      throw new Error(`Upload failed: ${error.message}`);
    }
  }

  async createFolder(folderData: FileUploadDTO): Promise<FileResponseDTO> {
    try {
      const folder = await this.prisma.file.create({
        data: {
          ...folderData,
          id: Math.random().toString(36).substr(2, 9),
          size: 0,
          createdAt: new Date(),
          updatedAt: new Date(),
          isFolder: true,
        },
      });

      return {
        id: folder.id,
        name: folder.name,
        type: folder.type,
        size: folder.size,
        path: folder.path,
        createdAt: folder.createdAt,
        updatedAt: folder.updatedAt,
        isFolder: folder.isFolder,
        folderId: folder.folderId,
        thumbnail: folder.thumbnail,
      };
    } catch (error: any) {
      console.error("Create folder error:", error);
      throw new Error(`Folder creation failed: ${error.message}`);
    }
  }

  async deleteFile(fileId: string): Promise<void> {
    try {
      await axios.delete(`${this.storageBackendUrl}/api/storage/${fileId}`);
      await this.prisma.file.delete({
        where: { id: fileId },
      });
    } catch (error: any) {
      if (error instanceof AxiosError) {
        console.error("Axios error details:", {
          status: error.response?.status,
          data: error.response?.data,
          message: error.message,
          config: error.config,
        });
        throw new Error(
          `Storage backend error: ${
            error.response?.status || "unknown"
          } - ${JSON.stringify(error.response?.data || error.message)}`
        );
      }
      console.error("Delete error:", error);
      throw new Error(`Delete failed: ${error.message}`);
    }
  }

  async moveFile(fileId: string, folderId?: string): Promise<FileResponseDTO> {
    try {
      const file = await this.prisma.file.update({
        where: { id: fileId },
        data: { folderId: folderId || null },
      });

      await axios.put(`${this.storageBackendUrl}/api/storage/${fileId}/move`, {
        folderId,
      });

      return {
        id: file.id,
        name: file.name,
        type: file.type,
        size: file.size,
        path: file.path,
        createdAt: file.createdAt,
        updatedAt: file.updatedAt,
        isFolder: file.isFolder,
        folderId: file.folderId,
        thumbnail: file.thumbnail,
      };
    } catch (error: any) {
      if (error instanceof AxiosError) {
        console.error("Axios error details:", {
          status: error.response?.status,
          data: error.response?.data,
          message: error.message,
          config: error.config,
        });
        throw new Error(
          `Storage backend error: ${
            error.response?.status || "unknown"
          } - ${JSON.stringify(error.response?.data || error.message)}`
        );
      }
      console.error("Move error:", error);
      throw new Error(`Move failed: ${error.message}`);
    }
  }
}

==== ./frontend-backend/src/types/index.ts ====

export interface File {
  id: string;
  name: string;
  type: string;
  size: number;
  path: string;
  createdAt: Date;
  updatedAt: Date;
  isFolder: boolean;
  folderId?: string;
  thumbnail?: string;
}
==== ./frontend-backend/src/config/database.ts ====

import mysql from "mysql2/promise";
import dotenv from "dotenv";

dotenv.config();

export async function initializeDatabase() {
  const databaseUrl = process.env.DATABASE_URL;
  if (!databaseUrl) {
    throw new Error("DATABASE_URL environment variable is not defined");
  }

  const [userInfo, hostInfo] = databaseUrl.split("@");
  const [user, password] = userInfo.split("://")[1].split(":");
  const [host, portAndDb] = hostInfo.split(":");
  const [port, dbName] = portAndDb.split("/");

  const connection = await mysql.createConnection({
    host: host || "localhost",
    port: parseInt(port) || 3306,
    user: user || "root",
    password: password || "password",
  });

  const finalDbName = dbName.split("?")[0] || "frontend_file_library";
  await connection.query(`CREATE DATABASE IF NOT EXISTS ${finalDbName}`);
  await connection.end();
}

==== ./frontend-backend/src/controllers/FileController.ts ====

import {
  JsonController,
  Get,
  Post,
  Delete,
  Put,
  QueryParam,
  Body,
  Param,
  HttpError,
} from "routing-controllers";
import { validate } from "class-validator";
import { FileService } from "../services/FileService";
import { FileUploadDTO } from "../dtos/FileUploadDTO";
import { FileResponseDTO } from "../dtos/FileResponseDTO";

@JsonController("/api")
export class FileController {
  private fileService: FileService;

  constructor() {
    this.fileService = new FileService();
  }

  @Get("/files")
  async getFiles(
    @QueryParam("folderId") folderId?: string
  ): Promise<FileResponseDTO[]> {
    try {
      return await this.fileService.getFiles(folderId);
    } catch (error: any) {
      throw new HttpError(500, `Failed to fetch files: ${error.message}`);
    }
  }

  @Post("/files/upload")
  async uploadFile(
    @Body() uploadData: FileUploadDTO
  ): Promise<FileResponseDTO> {
    try {
      const errors = await validate(uploadData);
      if (errors.length > 0) {
        throw new HttpError(
          400,
          `Validation failed: ${JSON.stringify(errors)}`
        );
      }
      return await this.fileService.uploadFile(uploadData);
    } catch (error: any) {
      throw new HttpError(500, `Failed to upload file: ${error.message}`);
    }
  }

  @Post("/folders")
  async createFolder(
    @Body() folderData: FileUploadDTO
  ): Promise<FileResponseDTO> {
    try {
      const errors = await validate(folderData);
      if (errors.length > 0) {
        throw new HttpError(
          400,
          `Validation failed: ${JSON.stringify(errors)}`
        );
      }
      return await this.fileService.createFolder(folderData);
    } catch (error: any) {
      throw new HttpError(500, `Failed to create folder: ${error.message}`);
    }
  }

  @Delete("/files/:id")
  async deleteFile(@Param("id") fileId: string): Promise<{ message: string }> {
    try {
      await this.fileService.deleteFile(fileId);
      return { message: "File deleted successfully" };
    } catch (error: any) {
      throw new HttpError(500, `Failed to delete file: ${error.message}`);
    }
  }

  @Put("/files/:id/move")
  async moveFile(
    @Param("id") fileId: string,
    @Body() body: { folderId?: string }
  ): Promise<FileResponseDTO> {
    try {
      return await this.fileService.moveFile(fileId, body.folderId);
    } catch (error: any) {
      throw new HttpError(500, `Failed to move file: ${error.message}`);
    }
  }
}

==== ./frontend-backend/src/dtos/FileResponseDTO.ts ====

export class FileResponseDTO {
  id!: string;
  name!: string;
  type!: string;
  size!: number;
  path!: string;
  createdAt!: Date;
  updatedAt!: Date;
  isFolder!: boolean;
  folderId!: string | null;
  thumbnail!: string | null;
}

==== ./frontend-backend/src/dtos/FileUploadDTO.ts ====

import { IsString, IsNotEmpty, IsOptional, IsUUID } from "class-validator";

export class FileUploadDTO {
  @IsString()
  @IsNotEmpty()
  name!: string;

  @IsString()
  @IsNotEmpty()
  type!: string;

  @IsString()
  @IsNotEmpty()
  path!: string;

  @IsOptional()
  @IsUUID()
  folderId?: string;
}

==== ./frontend-backend/src/index.ts ====

import "reflect-metadata"; // Must be imported first
import express from "express";
import { useExpressServer } from "routing-controllers";
import cors from "cors";
import { createServer } from "http";
import dotenv from "dotenv";
import { initializeDatabase } from "./config/database";
import { FileController } from "./controllers/FileController";
import { PrismaClient } from "@prisma/client";

dotenv.config();

async function main() {
  await initializeDatabase();
  console.log(
    "Successfully connected to MySQL database: frontend_file_library"
  );

  const prisma = new PrismaClient({
    log: ["query", "info", "warn", "error"],
    errorFormat: "pretty",
  });
  try {
    await prisma.$connect();
    console.log("Prisma successfully connected to the database");
    await prisma.file.findMany({ take: 1 });
    console.log("Prisma schema validated successfully");
  } catch (error) {
    console.error("Prisma failed to connect to the database:", error);
    process.exit(1);
  }

  const app = express();
  const port = process.env.PORT || 3001;

  // Explicitly use express.json() first to handle JSON parsing
  app.use(express.json({ limit: "10mb" }));
  app.use(cors());

  const server = createServer(app);

  useExpressServer(app, {
    controllers: [FileController],
    defaultErrorHandler: false,
    defaults: {
      paramOptions: {
        required: true,
      },
    },
  });

  server.listen(port, () => {
    console.log(`Frontend backend running on port ${port}`);
  });
}

main().catch((error) => {
  console.error("Failed to start Frontend Backend:", error);
  process.exit(1);
});

==== ./frontend-backend/nodemon.json ====

{
  "watch": ["dist"],
  "ext": "js",
  "exec": "node dist/index.js"
}